(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading wasm modules
/******/ 	var installedWasmModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// object with all compiled WebAssembly.Modules
/******/ 	__webpack_require__.w = {};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dom.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dom.ts":
/*!****************!*\
  !*** ./dom.ts ***!
  \****************/
/*! exports provided: TABLE_BLOCK_TYPE, HEADER_BLOCK_TYPE, PARAGRAPH_BLOCK_TYPE, UNORDERED_LIST_BLOCK_TYPE, RUN_SPAN_TYPE, PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE, PARAGRAPH_BLOCK_LINK_SPAN_TYPE, HEADER_BLOCK_LINK_SPAN_TYPE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TABLE_BLOCK_TYPE", function() { return TABLE_BLOCK_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEADER_BLOCK_TYPE", function() { return HEADER_BLOCK_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARAGRAPH_BLOCK_TYPE", function() { return PARAGRAPH_BLOCK_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNORDERED_LIST_BLOCK_TYPE", function() { return UNORDERED_LIST_BLOCK_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUN_SPAN_TYPE", function() { return RUN_SPAN_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE", function() { return PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARAGRAPH_BLOCK_LINK_SPAN_TYPE", function() { return PARAGRAPH_BLOCK_LINK_SPAN_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEADER_BLOCK_LINK_SPAN_TYPE", function() { return HEADER_BLOCK_LINK_SPAN_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MarkDownDOM; });
const TABLE_BLOCK_TYPE = 'table';
const HEADER_BLOCK_TYPE = 'header';
const PARAGRAPH_BLOCK_TYPE = 'paragraph';
const UNORDERED_LIST_BLOCK_TYPE = 'unordered-list';
const RUN_SPAN_TYPE = 'run';
const PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE = 'line-break';
const PARAGRAPH_BLOCK_LINK_SPAN_TYPE = 'link';
const HEADER_BLOCK_LINK_SPAN_TYPE = 'link';
class MarkDownDOM {
    constructor() {
        this.blocks = [];
    }
    static parse(source) {
        let state = { type: 'expectBlock' };
        try {
            const dom = new MarkDownDOM();
            for (let index = 0; index < source.length; index++) {
                const character = source[index];
                switch (state.type) {
                    case 'expectBlock': {
                        switch (character) {
                            case ' ': {
                                dom.pushParagraphBlock();
                                dom.pushParagraphBlockRunSpan(character);
                                state = { type: 'disambiguateWhiteSpaceParagraphBlock' };
                                break;
                            }
                            case '#': {
                                dom.pushHeaderBlock();
                                state = { type: 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock' };
                                break;
                            }
                            // TODO: Change to "paragraph until proven table", do not assume table straight away.
                            case '|': {
                                dom.pushTableBlock();
                                dom.pushTableBlockHeaderCell(); // TODO: Do not push the empty string yet, we don't know we need it, may be end of stream
                                state = { type: 'parseTableHeaderCell' };
                                break;
                            }
                            case '\n': {
                                dom.pushParagraphBlock();
                                state = { type: 'expectBlock' };
                                break;
                            }
                            default: {
                                dom.pushParagraphBlock();
                                dom.pushParagraphBlockRunSpan(character);
                                state = { type: 'advanceParagraphBlock' };
                                break;
                            }
                        }
                        break;
                    }
                    /* Table */
                    case 'parseTableHeaderCell': {
                        switch (character) {
                            case '|': {
                                // TODO: Not necessarily, may be followed by '\n' in which case it will be an extra phantom cell
                                // TODO: Do not enter the new cell prematurely, instead do it based on the next char
                                dom.pushTableBlockHeaderCell();
                                break;
                            }
                            case '\n': {
                                dom.pushTableBlockRow();
                                state = { type: 'parseTableBodyCell' };
                                break;
                            }
                            default: {
                                dom.appendCurrentTableBlockHeaderCellText(character);
                            }
                        }
                        break;
                    }
                    case 'parseTableBodyCell': {
                        switch (character) {
                            case '|': {
                                dom.pushTableBlockBodyCell();
                                break;
                            }
                            case '\n': {
                                dom.pushTableBlockBodyRow();
                                break;
                            }
                            default: {
                                dom.appendCurrentTableBlockBodyCellText(character);
                            }
                        }
                        break;
                    }
                    /* Header */
                    case 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock': {
                        switch (character) {
                            case '#': {
                                dom.bumpCurrentHeaderBlockLevel();
                                state = { type: 'appendHeaderBlockTextOrFinishHeaderBlock' };
                                break;
                            }
                            case '\n': {
                                state = { type: 'expectBlock' };
                                break;
                            }
                            default: {
                                dom.appendCurrentHeaderBlockRunSpanText(character);
                                state = { type: 'appendHeaderBlockTextOrFinishHeaderBlock' };
                                break;
                            }
                        }
                        break;
                    }
                    case 'appendHeaderBlockTextOrFinishHeaderBlock': {
                        switch (character) {
                            case '\n': {
                                state = { type: 'expectBlock' };
                                break;
                            }
                            case '(': {
                                const runSpan = dom.getCurrentHeaderBlockRunSpan();
                                if (runSpan.text.endsWith(']')) {
                                    state = { type: 'parsingLink', block: 'header' };
                                    index = index - 1; // Repeat
                                    break;
                                }
                                break;
                            }
                            default: {
                                if (dom.getCurrentHeaderBlockSpan().type !== 'run') {
                                    dom.pushHeaderBlockRunSpan(character);
                                }
                                dom.appendCurrentHeaderBlockRunSpanText(character);
                                break;
                            }
                        }
                        break;
                    }
                    /* Paragraph */
                    case 'disambiguateWhiteSpaceParagraphBlock': {
                        switch (character) {
                            case ' ': {
                                dom.appendCurrentParagraphBlockRunSpanText(character);
                                break;
                            }
                            case '\t': throw new Error('todo');
                            case '#': {
                                dom.pushHeaderBlockDisambiguatingParagraphBlock();
                                state = { type: 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock' };
                                break;
                            }
                            case '-': throw new Error('todo');
                            default: {
                                throw new Error('yo');
                            }
                        }
                        break;
                    }
                    // TODO: Looks ugly with all the switches, split into two?
                    case 'parsingLink': {
                        let runSpan;
                        switch (state.block) {
                            case 'paragraph':
                                runSpan = dom.getCurrentParagraphBlockRunSpan();
                                break;
                            case 'header':
                                runSpan = dom.getCurrentHeaderBlockRunSpan();
                                break;
                            default: throw new Error('Nope');
                        }
                        const index = runSpan.text.lastIndexOf('[');
                        const title = runSpan.text.substring(index + 1, runSpan.text.length - 1);
                        runSpan.text = runSpan.text.substring(0, index);
                        if (runSpan.text === '') {
                            switch (state.block) {
                                case 'paragraph':
                                    dom.popCurrentParagraphBlockRunSpan();
                                    break;
                                case 'header':
                                    dom.popCurrentHeaderBlockRunSpan();
                                    break;
                                default: throw new Error('Nope');
                            }
                        }
                        switch (state.block) {
                            case 'paragraph':
                                dom.pushParagraphBlockLinkSpan(title);
                                state = { type: 'parsingLinkTarget', block: 'paragraph' };
                                break;
                            case 'header':
                                dom.pushHeaderBlockLinkSpan(title);
                                state = { type: 'parsingLinkTarget', block: 'header' };
                                break;
                            default: throw new Error('Nope');
                        }
                        break;
                    }
                    // TODO: Looks ugly with all the switches, split into two?
                    case 'parsingLinkTarget': {
                        switch (character) {
                            case '(': break;
                            case ')': {
                                switch (state.block) {
                                    case 'paragraph':
                                        state = { type: 'advanceParagraphBlock' };
                                        break;
                                    case 'header':
                                        state = { type: 'appendHeaderBlockTextOrFinishHeaderBlock' };
                                        break;
                                    default: throw new Error('Nope');
                                }
                                break;
                            }
                            default: {
                                switch (state.block) {
                                    case 'paragraph':
                                        dom.getCurrentParagraphBlockLinkSpan().url += character;
                                        break;
                                    case 'header':
                                        dom.getCurrentHeaderBlockLinkSpan().url += character;
                                        break;
                                    default: throw new Error('Nope');
                                }
                            }
                        }
                        break;
                    }
                    case 'advanceParagraphBlock': {
                        switch (character) {
                            case '\r': throw new Error('\\r');
                            case '\n': {
                                switch (dom.getCurrentParagraphBlockSpan().type) {
                                    case 'line-break':
                                        dom.finalizeParagraph();
                                        state = { type: 'expectBlock' };
                                        break;
                                    case 'run':
                                        dom.pushParagraphBlockLineBreakSpan();
                                        break;
                                    default: throw new Error(`Unexpected span type '${dom.getCurrentParagraphBlockSpan().type}'`);
                                }
                                break;
                            }
                            case '*': {
                                throw new Error('italics or bold');
                            }
                            case '(': {
                                const runSpan = dom.getCurrentParagraphBlockRunSpan();
                                if (runSpan.text.endsWith(']')) {
                                    state = { type: 'parsingLink', block: 'paragraph' };
                                    index = index - 1; // Repeat
                                    break;
                                }
                                break;
                            }
                            default: {
                                switch (dom.getCurrentParagraphBlockSpan().type) {
                                    case 'line-break':
                                        dom.pushParagraphBlockRunSpan(character);
                                        break;
                                    case 'run':
                                        dom.appendCurrentParagraphBlockRunSpanText(character);
                                        break;
                                    case 'link':
                                        dom.pushParagraphBlockRunSpan(character);
                                        break;
                                    default: throw new Error(`Unexpected type '${dom.getCurrentParagraphBlockSpan().type}'`);
                                }
                            }
                        }
                        break;
                    }
                    default: throw new Error(`Invalid state '${state /* never */.type}' at index ${index}.`);
                }
            }
            // Fool types so we can have extra info for the viewer but nice types for the lib
            return Object.assign({}, dom, { state });
        }
        catch (error) {
            return { error: { message: error.message, stack: error.stack.split(/\n/g) }, state };
        }
    }
    serialize() {
        let source = '';
        for (const block of this.blocks) {
            switch (block.type) {
                case 'header': {
                    source += block.indent + '#'.repeat(block.level);
                    for (const span of block.spans) {
                        switch (span.type) {
                            case 'run': {
                                source += span.text;
                                break;
                            }
                        }
                    }
                    break;
                }
                case 'paragraph': {
                    for (const span of block.spans) {
                        switch (span.type) {
                            case 'run': {
                                source += span.text;
                                break;
                            }
                            default: {
                                source += 'todo';
                                break;
                            }
                        }
                    }
                    break;
                }
                default: {
                    source += 'todo';
                    break;
                }
            }
        }
        return source;
    }
    getCurrentBlock() {
        if (this.blocks.length === 0) {
            throw new Error('No blocks yet, cannot get current block.');
        }
        return this.blocks[this.blocks.length - 1];
    }
    /* Paragraph */
    getCurrentParagraphBlock() {
        const block = this.getCurrentBlock();
        if (block.type !== PARAGRAPH_BLOCK_TYPE) {
            throw new Error(`Current block type is ${block.type}, not ${PARAGRAPH_BLOCK_TYPE}.`);
        }
        return block;
    }
    getCurrentParagraphBlockSpan() {
        const block = this.getCurrentParagraphBlock();
        if (block.spans.length === 0) {
            throw new Error('No spans yet, cannot get current paragraph block span.');
        }
        return block.spans[block.spans.length - 1];
    }
    getCurrentParagraphBlockRunSpan() {
        const span = this.getCurrentParagraphBlockSpan();
        if (span.type !== RUN_SPAN_TYPE) {
            throw new Error(`Current span type is ${span.type}, not ${RUN_SPAN_TYPE}.`);
        }
        return span;
    }
    getCurrentParagraphBlockLinkSpan() {
        const span = this.getCurrentParagraphBlockSpan();
        if (span.type !== PARAGRAPH_BLOCK_LINK_SPAN_TYPE) {
            throw new Error(`Current span type is ${span.type}, not ${PARAGRAPH_BLOCK_LINK_SPAN_TYPE}.`);
        }
        return span;
    }
    getCurrentHeaderBlockLinkSpan() {
        const span = this.getCurrentHeaderBlockSpan();
        if (span.type !== HEADER_BLOCK_LINK_SPAN_TYPE) {
            throw new Error(`Current span type is ${span.type}, not ${HEADER_BLOCK_LINK_SPAN_TYPE}.`);
        }
        return span;
    }
    popCurrentParagraphBlockRunSpan() {
        const span = this.getCurrentParagraphBlockRunSpan();
        const block = this.getCurrentParagraphBlock();
        if (block.spans[block.spans.length - 1] !== span) {
            throw new Error('Mismatch!');
        }
        block.spans.pop();
    }
    popCurrentHeaderBlockRunSpan() {
        const span = this.getCurrentHeaderBlockSpan();
        const block = this.getCurrentHeaderBlock();
        if (span.type !== RUN_SPAN_TYPE) {
            throw new Error(`Current span type is ${span.type}, not ${RUN_SPAN_TYPE}.`);
        }
        block.spans.pop();
    }
    pushParagraphBlock() {
        this.blocks.push({ type: PARAGRAPH_BLOCK_TYPE, spans: [] });
    }
    pushParagraphBlockRunSpan(text) {
        const block = this.getCurrentParagraphBlock();
        block.spans.push({ type: RUN_SPAN_TYPE, text });
    }
    pushParagraphBlockLineBreakSpan() {
        const block = this.getCurrentParagraphBlock();
        block.spans.push({ type: PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE });
    }
    pushParagraphBlockLinkSpan(text) {
        const block = this.getCurrentParagraphBlock();
        block.spans.push({ type: PARAGRAPH_BLOCK_LINK_SPAN_TYPE, text, url: '' });
    }
    pushHeaderBlockLinkSpan(text) {
        const block = this.getCurrentHeaderBlock();
        block.spans.push({ type: HEADER_BLOCK_LINK_SPAN_TYPE, text, url: '' });
    }
    pushHeaderBlockRunSpan(character) {
        const block = this.getCurrentHeaderBlock();
        block.spans.push({ type: RUN_SPAN_TYPE, text: character });
    }
    appendCurrentParagraphBlockRunSpanText(char) {
        this.getCurrentParagraphBlockRunSpan().text += char;
    }
    finalizeParagraph() {
        this.getCurrentParagraphBlock().spans.pop();
    }
    /* Header */
    getCurrentHeaderBlock() {
        const block = this.getCurrentBlock();
        if (block.type !== HEADER_BLOCK_TYPE) {
            throw new Error(`Current block type is ${block.type}, not ${HEADER_BLOCK_TYPE}.`);
        }
        return block;
    }
    getCurrentTableBlock() {
        const block = this.getCurrentBlock();
        if (block.type !== TABLE_BLOCK_TYPE) {
            throw new Error(`Current block type is ${block.type}, not ${TABLE_BLOCK_TYPE}.`);
        }
        return block;
    }
    getCurrentHeaderBlockSpan() {
        const block = this.getCurrentHeaderBlock();
        if (block.spans.length === 0) {
            throw new Error('No spans yet, cannot get current header block span.');
        }
        return block.spans[block.spans.length - 1];
    }
    getCurrentHeaderBlockRunSpan() {
        const span = this.getCurrentHeaderBlockSpan();
        if (span.type !== RUN_SPAN_TYPE) {
            throw new Error(`Current span type is ${span.type}, not ${RUN_SPAN_TYPE}.`);
        }
        return span;
    }
    pushHeaderBlock(indent = '') {
        this.blocks.push({ type: HEADER_BLOCK_TYPE, level: 1, spans: [], indent });
    }
    pushTableBlock() {
        this.blocks.push({ type: TABLE_BLOCK_TYPE, header: [], body: [] });
    }
    pushTableBlockHeaderCell() {
        this.getCurrentTableBlock().header.push('');
    }
    pushTableBlockRow() {
        this.getCurrentTableBlock().body.push([]);
    }
    pushTableBlockBodyCell() {
        const body = this.getCurrentTableBlock().body;
        if (body.length === 0) {
            throw new Error('Not today');
        }
        body[body.length - 1].push('');
    }
    pushTableBlockBodyRow() {
        const body = this.getCurrentTableBlock().body;
        body.push([]);
    }
    appendCurrentTableBlockHeaderCellText(character) {
        const block = this.getCurrentTableBlock();
        if (block.header.length === 0) {
            throw new Error('Nada');
        }
        block.header[block.header.length - 1] += character;
    }
    appendCurrentTableBlockBodyCellText(character) {
        const block = this.getCurrentTableBlock();
        if (block.body.length === 0 || block.body[0].length === 0) {
            throw new Error(':-(');
        }
        const row = block.body[block.body.length - 1];
        row[row.length - 1] += character;
    }
    pushHeaderBlockDisambiguatingParagraphBlock() {
        const block = this.getCurrentParagraphBlock();
        if (block.spans.length !== 1) {
            throw new Error('Paragraph block is supposed to be ambiguous, but has multiple spans!');
        }
        const span = this.getCurrentParagraphBlockRunSpan();
        if (span.text.trim() !== '') {
            throw new Error('Run span is supposed to be ambiguous, but has non-whitespace characters!');
        }
        this.blocks.pop(); // Remove ambiguous paragraph.
        this.pushHeaderBlock(span.text);
    }
    bumpCurrentHeaderBlockLevel() {
        this.getCurrentHeaderBlock().level++;
    }
    appendCurrentHeaderBlockRunSpanText(char) {
        if (this.getCurrentHeaderBlock().spans.length === 0) {
            this.getCurrentHeaderBlock().spans = [{ type: RUN_SPAN_TYPE, text: char }];
        }
        else {
            this.getCurrentHeaderBlockRunSpan().text += char;
        }
    }
}


/***/ })

/******/ });
});
//# sourceMappingURL=main.js.map