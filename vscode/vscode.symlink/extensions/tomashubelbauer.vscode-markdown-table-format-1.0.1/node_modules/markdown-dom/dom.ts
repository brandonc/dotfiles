type State =
	| { type: 'expectBlock' }
	| { type: 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock' }
	| { type: 'appendHeaderBlockTextOrFinishHeaderBlock' }
	| { type: 'disambiguateWhiteSpaceParagraphBlock' }
	| { type: 'disambiguateUnorderedListParagraphBlock' }
	| { type: 'advanceParagraphBlock' }
	| { type: 'advanceParagraphBlockLinkSpanText' }
	| { type: 'parsingLinkTarget'; block: 'paragraph' | 'header'; }
	| { type: 'parsingLink'; block: 'paragraph' | 'header'; }
	| { type: 'parseTableHeaderCell' }
	| { type: 'parseTableBodyCell' }
	;

export const TABLE_BLOCK_TYPE = 'table';
export type MarkDownTableBlock = { type: typeof TABLE_BLOCK_TYPE; header: string[]; body: string[][]; };

export const HEADER_BLOCK_TYPE = 'header';
export type MarkDownHeaderBlock = { type: typeof HEADER_BLOCK_TYPE; level: number; spans: MarkDownHeaderBlockSpan[]; indent: string; };

export const PARAGRAPH_BLOCK_TYPE = 'paragraph';
export type MarkDownParagraphBlock = { type: typeof PARAGRAPH_BLOCK_TYPE; spans: MarkDownParagraphBlockSpan[]; };

export const UNORDERED_LIST_BLOCK_TYPE = 'unordered-list';
export type MarkDownUnorderedListBlock = { type: typeof UNORDERED_LIST_BLOCK_TYPE; items: MarkDownUnorderedListBlockItem[]; };

export type MarkDownBlock =
	| MarkDownTableBlock
	| MarkDownHeaderBlock
	| MarkDownParagraphBlock
	| MarkDownUnorderedListBlock
;

export const RUN_SPAN_TYPE = 'run';
export type MarkDownRunSpan = { type: typeof RUN_SPAN_TYPE; text: string; };

export type MarkDownHeaderBlockSpan =
	| MarkDownRunSpan
	| MarkDownHeaderBlockLinkSpan
;

export const PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE = 'line-break';
export type MarkDownParagraphBlockLineBreakSpan = { type: typeof PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE; };

export const PARAGRAPH_BLOCK_LINK_SPAN_TYPE = 'link';
export type MarkDownParagraphBlockLinkSpan = { type: typeof PARAGRAPH_BLOCK_LINK_SPAN_TYPE; text: string; url: string; };

export const HEADER_BLOCK_LINK_SPAN_TYPE = 'link';
export type MarkDownHeaderBlockLinkSpan = { type: typeof HEADER_BLOCK_LINK_SPAN_TYPE; text: string; url: string; };

export type MarkDownParagraphBlockSpan =
	| MarkDownRunSpan
	| MarkDownParagraphBlockLineBreakSpan
	| MarkDownParagraphBlockLinkSpan
;

export type MarkDownUnorderedListBlockItem = { text: string; };

export default class MarkDownDOM {
	// TODO: Make this private and instead have a getter
	public readonly blocks: MarkDownBlock[];

	private constructor() {
		this.blocks = [];
	}

	public static parse(source: string) {
		let state: State = { type: 'expectBlock' };
		try {
			const dom = new MarkDownDOM();
		
			for (let index = 0; index < source.length; index++) {
				const character = source[index];
				switch (state.type) {
					case 'expectBlock': {
						switch (character) {
							case ' ': {
								dom.pushParagraphBlock();
								dom.pushParagraphBlockRunSpan(character);
								state = { type: 'disambiguateWhiteSpaceParagraphBlock' };
								break;
							}
							case '#': {
								dom.pushHeaderBlock();
								state = { type: 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock' };
								break;
							}
							// TODO: Change to "paragraph until proven table", do not assume table straight away.
							case '|': {
								dom.pushTableBlock();
								dom.pushTableBlockHeaderCell(); // TODO: Do not push the empty string yet, we don't know we need it, may be end of stream
								state = { type: 'parseTableHeaderCell' };
								break;
							}
							case '\n': {
								dom.pushParagraphBlock();
								state = { type: 'expectBlock' };
								break;
							}
							default: {
								dom.pushParagraphBlock();
								dom.pushParagraphBlockRunSpan(character);
								state = { type: 'advanceParagraphBlock' };
								break;
							}
						}
		
						break;
					}

					/* Table */

					case 'parseTableHeaderCell': {
						switch (character) {
							case '|': {
								// TODO: Not necessarily, may be followed by '\n' in which case it will be an extra phantom cell
								// TODO: Do not enter the new cell prematurely, instead do it based on the next char
								dom.pushTableBlockHeaderCell(); 
								break;
							}
							case '\n': {
								dom.pushTableBlockRow();
								state = { type: 'parseTableBodyCell' };
								break;
							}
							default: {
								dom.appendCurrentTableBlockHeaderCellText(character);
							}
						}

						break;
					}

					case 'parseTableBodyCell': {
						switch (character) {
							case '|': {
								dom.pushTableBlockBodyCell();
								break;
							}
							case '\n': {
								dom.pushTableBlockBodyRow();
								break;
							}
							default: {
								dom.appendCurrentTableBlockBodyCellText(character);
							}
						}

						break;
					}

					/* Header */

					case 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock': {
						switch (character) {
							case '#': {
								dom.bumpCurrentHeaderBlockLevel();
								state = { type: 'appendHeaderBlockTextOrFinishHeaderBlock' };
								break;
							}
							case '\n': {
								state = { type: 'expectBlock' };
								break;
							}
							default: {
								dom.appendCurrentHeaderBlockRunSpanText(character);
								state = { type: 'appendHeaderBlockTextOrFinishHeaderBlock' };
								break;
							}
						}

						break;
					}

					case 'appendHeaderBlockTextOrFinishHeaderBlock': {
						switch (character) {
							case '\n': {
								state = { type: 'expectBlock' };
								break;
							}
							case '(': {
								const runSpan = dom.getCurrentHeaderBlockRunSpan();
								if (runSpan.text.endsWith(']')) {
									state = { type: 'parsingLink', block: 'header' };
									index = index - 1; // Repeat
									break;
								}

								break;
							}
							default: {
								if (dom.getCurrentHeaderBlockSpan().type !== 'run') {
									dom.pushHeaderBlockRunSpan(character);
								}

								dom.appendCurrentHeaderBlockRunSpanText(character);
								break;
							}
						}

						break;
					}

					/* Paragraph */

					case 'disambiguateWhiteSpaceParagraphBlock': {
						switch (character) {
							case ' ': {
								dom.appendCurrentParagraphBlockRunSpanText(character);
								break;
							}
							case '\t': throw new Error('todo');
							case '#': {
								dom.pushHeaderBlockDisambiguatingParagraphBlock();
								state = { type: 'bumpHeaderBlockLevelOrAppendHeaderBlockTextOrFinishHeaderBlock' };
								break;
							}
							case '-': throw new Error('todo');
							default: {
								throw new Error('yo');
							}
						}

						break;
					}

					// TODO: Looks ugly with all the switches, split into two?
					case 'parsingLink': {
						let runSpan: MarkDownRunSpan;
						switch (state.block) {
							case 'paragraph': runSpan = dom.getCurrentParagraphBlockRunSpan(); break;
							case 'header': runSpan = dom.getCurrentHeaderBlockRunSpan(); break;
							default: throw new Error('Nope');
						}

						const index = runSpan.text.lastIndexOf('[');
						const title = runSpan.text.substring(index + 1, runSpan.text.length - 1);
						runSpan.text = runSpan.text.substring(0, index);
						if (runSpan.text === '') {
							switch (state.block) {
								case 'paragraph': dom.popCurrentParagraphBlockRunSpan(); break;
								case 'header': dom.popCurrentHeaderBlockRunSpan(); break;
								default: throw new Error('Nope');
							}
						}

						switch (state.block) {
							case 'paragraph': dom.pushParagraphBlockLinkSpan(title); state = { type: 'parsingLinkTarget', block: 'paragraph' }; break;
							case 'header': dom.pushHeaderBlockLinkSpan(title); state = { type: 'parsingLinkTarget', block: 'header' }; break;
							default: throw new Error('Nope');
						}

						break;
					}

					// TODO: Looks ugly with all the switches, split into two?
					case 'parsingLinkTarget': {
						switch (character) {
							case '(': break;
							case ')': {
								switch (state.block) {
									case 'paragraph': state = { type: 'advanceParagraphBlock' }; break;
									case 'header': state = { type: 'appendHeaderBlockTextOrFinishHeaderBlock' }; break;
									default: throw new Error('Nope');
								}

								break;
							}
							default: {
								switch (state.block) {
									case 'paragraph': dom.getCurrentParagraphBlockLinkSpan().url += character; break;
									case 'header': dom.getCurrentHeaderBlockLinkSpan().url += character; break;
									default: throw new Error('Nope');
								}
							}
						}

						break;
					}

					case 'advanceParagraphBlock': {
						switch (character) {
							case '\r': throw new Error('\\r');
							case '\n': {
								switch (dom.getCurrentParagraphBlockSpan().type) {
									case 'line-break': dom.finalizeParagraph(); state = { type: 'expectBlock' }; break;
									case 'run': dom.pushParagraphBlockLineBreakSpan(); break;
									default: throw new Error(`Unexpected span type '${dom.getCurrentParagraphBlockSpan().type}'`);
								}
		
								break;
							}
							case '*': {
								throw new Error('italics or bold');
							}
							case '(': {
								const runSpan = dom.getCurrentParagraphBlockRunSpan();
								if (runSpan.text.endsWith(']')) {
									state = { type: 'parsingLink', block: 'paragraph' };
									index = index - 1; // Repeat
									break;
								}

								break;
							}
							default: {
								switch (dom.getCurrentParagraphBlockSpan().type) {
									case 'line-break': dom.pushParagraphBlockRunSpan(character); break;
									case 'run': dom.appendCurrentParagraphBlockRunSpanText(character); break;
									case 'link': dom.pushParagraphBlockRunSpan(character); break;
									default: throw new Error(`Unexpected type '${dom.getCurrentParagraphBlockSpan().type}'`);
								}
							}
						}
		
						break;
					}
		
					default: throw new Error(`Invalid state '${(state as State /* never */).type}' at index ${index}.`);
				}
			}

			// Fool types so we can have extra info for the viewer but nice types for the lib
			return ({ ...dom, state } as any) as MarkDownDOM;
		} catch (error) {
			return ({ error: { message: error.message, stack: error.stack.split(/\n/g) }, state } as any) as MarkDownDOM;
		}
	}

	public serialize() {
		let source = '';
		for (const block of this.blocks) {
			switch (block.type) {
				case 'header': {
					source += block.indent + '#'.repeat(block.level);
					for (const span of block.spans) {
						switch (span.type) {
							case 'run': {
								source += span.text;
								break;
							}
						}
					}

					break;
				}

				case 'paragraph': {
					for (const span of block.spans) {
						switch (span.type) {
							case 'run': {
								source += span.text;
								break;
							}
							default: {
								source += 'todo';
								break;
							}
						}
					}
					break;
				}

				default: {
					source += 'todo';
					break;
				}
			}
		}

		return source;
	}

	public getCurrentBlock() {
		if (this.blocks.length === 0) {
			throw new Error('No blocks yet, cannot get current block.');
		}

		return this.blocks[this.blocks.length - 1];
	}

	/* Paragraph */

	public getCurrentParagraphBlock() {
		const block = this.getCurrentBlock();
		if (block.type !== PARAGRAPH_BLOCK_TYPE) {
			throw new Error(`Current block type is ${block.type}, not ${PARAGRAPH_BLOCK_TYPE}.`);
		}

		return block;
	}

	public getCurrentParagraphBlockSpan() {
		const block = this.getCurrentParagraphBlock();
		if (block.spans.length === 0) {
			throw new Error('No spans yet, cannot get current paragraph block span.');
		}

		return block.spans[block.spans.length - 1];
	}

	public getCurrentParagraphBlockRunSpan() {
		const span = this.getCurrentParagraphBlockSpan();
		if (span.type !== RUN_SPAN_TYPE) {
			throw new Error(`Current span type is ${span.type}, not ${RUN_SPAN_TYPE}.`);
		}

		return span;
	}

	public getCurrentParagraphBlockLinkSpan() {
		const span = this.getCurrentParagraphBlockSpan();
		if (span.type !== PARAGRAPH_BLOCK_LINK_SPAN_TYPE) {
			throw new Error(`Current span type is ${span.type}, not ${PARAGRAPH_BLOCK_LINK_SPAN_TYPE}.`);
		}

		return span;
	}

	public getCurrentHeaderBlockLinkSpan() {
		const span = this.getCurrentHeaderBlockSpan();
		if (span.type !== HEADER_BLOCK_LINK_SPAN_TYPE) {
			throw new Error(`Current span type is ${span.type}, not ${HEADER_BLOCK_LINK_SPAN_TYPE}.`);
		}

		return span;
	}

	public popCurrentParagraphBlockRunSpan() {
		const span = this.getCurrentParagraphBlockRunSpan();
		const block = this.getCurrentParagraphBlock();
		if (block.spans[block.spans.length - 1] !== span) {
			throw new Error('Mismatch!');
		}

		block.spans.pop();
	}

	public popCurrentHeaderBlockRunSpan() {
		const span = this.getCurrentHeaderBlockSpan();
		const block = this.getCurrentHeaderBlock();
		if (span.type !== RUN_SPAN_TYPE) {
			throw new Error(`Current span type is ${span.type}, not ${RUN_SPAN_TYPE}.`);
		}

		block.spans.pop();
	}

	public pushParagraphBlock() {
		this.blocks.push({ type: PARAGRAPH_BLOCK_TYPE, spans: [ ] });
	}

	public pushParagraphBlockRunSpan(text: string) {
		const block = this.getCurrentParagraphBlock();
		block.spans.push({ type: RUN_SPAN_TYPE, text });
	}

	public pushParagraphBlockLineBreakSpan() {
		const block = this.getCurrentParagraphBlock();
		block.spans.push({ type: PARAGRAPH_BLOCK_LINE_BREAK_SPAN_TYPE });
	}

	public pushParagraphBlockLinkSpan(text: string) {
		const block = this.getCurrentParagraphBlock();
		block.spans.push({ type: PARAGRAPH_BLOCK_LINK_SPAN_TYPE, text, url: '' });
	}

	public pushHeaderBlockLinkSpan(text: string) {
		const block = this.getCurrentHeaderBlock();
		block.spans.push({ type: HEADER_BLOCK_LINK_SPAN_TYPE, text, url: '' });
	}

	public pushHeaderBlockRunSpan(character: string) {
		const block = this.getCurrentHeaderBlock();
		block.spans.push({ type: RUN_SPAN_TYPE, text: character });
	}

	public appendCurrentParagraphBlockRunSpanText(char: string) {
		this.getCurrentParagraphBlockRunSpan().text += char;
	}

	public finalizeParagraph() {
		this.getCurrentParagraphBlock().spans.pop();
	}

	/* Header */

	public getCurrentHeaderBlock() {
		const block = this.getCurrentBlock();
		if (block.type !== HEADER_BLOCK_TYPE) {
			throw new Error(`Current block type is ${block.type}, not ${HEADER_BLOCK_TYPE}.`);
		}

		return block;
	}

	public getCurrentTableBlock() {
		const block = this.getCurrentBlock();
		if (block.type !== TABLE_BLOCK_TYPE) {
			throw new Error(`Current block type is ${block.type}, not ${TABLE_BLOCK_TYPE}.`);
		}

		return block;
	}

	public getCurrentHeaderBlockSpan() {
		const block = this.getCurrentHeaderBlock();
		if (block.spans.length === 0) {
			throw new Error('No spans yet, cannot get current header block span.');
		}

		return block.spans[block.spans.length - 1];
	}

	public getCurrentHeaderBlockRunSpan() {
		const span = this.getCurrentHeaderBlockSpan();
		if (span.type !== RUN_SPAN_TYPE) {
			throw new Error(`Current span type is ${span.type}, not ${RUN_SPAN_TYPE}.`);
		}

		return span;
	}

	public pushHeaderBlock(indent: string = '') {
		this.blocks.push({ type: HEADER_BLOCK_TYPE, level: 1, spans: [ ], indent });
	}

	public pushTableBlock() {
		this.blocks.push({ type: TABLE_BLOCK_TYPE, header: [], body: [] });
	}

	public pushTableBlockHeaderCell() {
		this.getCurrentTableBlock().header.push('');
	}

	public pushTableBlockRow() {
		this.getCurrentTableBlock().body.push([]);
	}
	public pushTableBlockBodyCell() {
		const body = this.getCurrentTableBlock().body;
		if (body.length === 0) {
			throw new Error('Not today');
		}

		body[body.length - 1].push('');
	}

	public pushTableBlockBodyRow() {
		const body = this.getCurrentTableBlock().body;
		body.push([]);
	}

	public appendCurrentTableBlockHeaderCellText(character: string) {
		const block = this.getCurrentTableBlock();
		if (block.header.length === 0) {
			throw new Error('Nada');
		}

		block.header[block.header.length - 1] += character;
	}

	public appendCurrentTableBlockBodyCellText(character: string) {
		const block = this.getCurrentTableBlock();
		if (block.body.length === 0 || block.body[0].length === 0) {
			throw new Error(':-(');
		}

		const row = block.body[block.body.length - 1];
		row[row.length - 1] += character;
	}

	public pushHeaderBlockDisambiguatingParagraphBlock() {
		const block = this.getCurrentParagraphBlock();
		if (block.spans.length !== 1) {
			throw new Error('Paragraph block is supposed to be ambiguous, but has multiple spans!');
		}

		const span = this.getCurrentParagraphBlockRunSpan();
		if (span.text.trim() !== '') {
			throw new Error('Run span is supposed to be ambiguous, but has non-whitespace characters!');
		}

		this.blocks.pop(); // Remove ambiguous paragraph.
		this.pushHeaderBlock(span.text);
	}

	public bumpCurrentHeaderBlockLevel() {
		this.getCurrentHeaderBlock().level++;
	}

	public appendCurrentHeaderBlockRunSpanText(char: string) {
		if (this.getCurrentHeaderBlock().spans.length === 0) {
			this.getCurrentHeaderBlock().spans = [ { type: RUN_SPAN_TYPE, text: char } ];
		} else {
			this.getCurrentHeaderBlockRunSpan().text += char;
		}
	}

}
